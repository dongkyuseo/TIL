# Pandas

## 판다스 데이터 분석

- Numpy : 행row 열col 위주
- Pandas
  - Series가 묶여있는 2차원 표 = DataFrame 위주
    - series 열 하나 하나의미 numpy 값으로 가지고 있으나 index를 가지고 있음
  - 시리즈와 데이터프레임을 만들 수 있다.
  - 판다스를 이용하여 csv 파일을 읽고 쓸 수 있다.
    - 엑셀보다 더많은 데이터를 작업 할 수 있음.
  - 시리즈와 데이터프레임에서 원하는 데이터를 읽고 갱신하는 방법을 익힌다.
  - 시리즈와 데이터프레임의 데이터를 조작하는 법을 공부한다.
  - 멀티 인덱스와 이를 다루는 방법을 학습한다.
  - 둘 이상의 데이터프레임을 하나로 합치는 법을 익힌다.
  - 데이터를 그룹으로 나누어 분석하고 피봇테이블을 만드는 방법을 공부한다.

## Series

- 시리즈의 값은 시리즈 단독 사용보다 데이터 프레임으로 많이 사용 됨
- 시작하기 전 아래 2개 필수

```python
import numpy as np
import pandas as pd
```

- 시리즈 = 값(value) + 인덱스(index)
  - 시리즈는 데이터의 type은 넘파이와 같음
- 시리즈 생성방법

```python
s = pd.Series(값)
```

- 값을 주는 방법은 여러가지 임

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052])
s

0    9904312
1    3448737
2    2890451
3    2466052
dtype: int64
```

- 넘파이 기반의 타입, 
- index를 지정하지 않으면 0 1 2 3 인덱스가 생김

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"], dtype=np.int32)
s

서울    9904312
부산    3448737
인천    2890451
대구    2466052
dtype: int32
```

- 시리즈에 인덱스 값 부여, 타입 지정 가능

```python
# 시리즈의 값 - 넘파이 배열
s.values
array([9904312, 3448737, 2890451, 2466052])

# 시리즈의 인덱스
s.index
Index(['서울', '부산', '인천', '대구'], dtype='object')
```

```python
# 시리즈의 이름 설정 가능
s.name = '인구'
s.index.name = '도시'
s

도시
서울    9904312
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int32
```

### 시리즈의 연산

```python
s / 1000000

도시
서울    9.904312
부산    3.448737
인천    2.890451
대구    2.466052
Name: 인구, dtype: float64
```

- 값 만 변경 됨, 시리즈의 데이터는 넘파이 기반이기 때문

### 시리즈 인덱싱

```python
s[1], s['부산']
(3448737, 3448737)
```

- 인덱스값 호출 방법

```python
s[[0,3,1]], s[["서울", "대구", "부산"]]

(도시
 서울    9904312
 대구    2466052
 부산    3448737
 Name: 인구, dtype: int32,
 도시
 서울    9904312
 대구    2466052
 부산    3448737
 Name: 인구, dtype: int32)
```

- 인덱스는 키와 같음
- 리스트 형태로 호출시 시리즈 형식으로 볼 수 있음
- 넘파이의 fancy indexing 과 같음

```python
# slicing
s[1:3]
도시
부산    3448737
인천    2890451
Name: 인구, dtype: int32
s['부산':'대구']
도시
부산    3448737
인천    2890451
대구    2466052
Name: 인구, dtype: int32
```

- 슬라이싱시 인덱스 번호가 아닌 인덱스 명으로 호출시 호출한 인덱스까지 출력 됨

```python
# 필터링
# $ - and
s[(2500000 < s) & (s<3000000)]
# s[2500000 < s < 3000000] 은 사용 불가
도시
인천    2890451
Name: 인구, dtype: int32
        
# | - or 
s[(s < 2500000) | (s > 4e6)]       
# e숫자 0의 갯수만큼 추가   
도시
서울    9904312
대구    2466052
Name: 인구, dtype: int32
```

```python
# 한글 인덱스도 호출 가능
s.부산

3448737
```

### 시리즈와 딕셔너리

```python
s2 = pd.Series({"서울": 9631482, "부산": 3393191, "인천": 2632035, "대전": 1490158})
s2

서울    9631482
부산    3393191
인천    2632035
대전    1490158
dtype: int64
    
'서울' in s, '대구' in s2
(True, False)
```

- 딕셔너리와 같은 기능 가능
- 인덱스 명만으로도 in 과 같은 검사 가능
- 단, 딕셔너리를 활용한 시리즈 생성은 권장하지 않음 가능하다는 것만 인지, 딕셔너리는 정렬이 어려움

```python
s2 = pd.Series({"서울": 9631482, "부산": 3393191, "인천": 2632035, "대전": 1490158},
               index=["부산", "서울", "인천", "대전"])
s2
부산    3393191
서울    9631482
인천    2632035
대전    1490158
dtype: int64
```

- 위와 같이 인덱스를 따로 지정해 주어야 정렬 가능

### 인덱스 기반 연산

```python
s - s2
대구         NaN
대전         NaN
부산     55546.0
서울    272830.0
인천    258416.0
dtype: float64
```

- 키값이 같은 값이 있으면 빼주지만 다르면 안빼줌

```python
s.values - s2.values
array([272830,  55546, 258416, 975894], dtype=int64)
```

- values를 사용시 값끼리 빼주므로 넘파이 식으로 계산됨

```python
rs = (s - s2) / s2 * 100
rs

대구         NaN
대전         NaN
부산    1.636984
서울    2.832690
인천    9.818107
dtype: float64
    
rs.notnull()
대구    False
대전    False
부산     True
서울     True
인천     True
dtype: bool
    
rs[rs.notnull()]
부산    1.636984
서울    2.832690
인천    9.818107
dtype: float64
```

### 데이터의 갱신, 추가, 삭제

```python
# 데이터 갱신
rs['부산'] = 1.63
rs
부산    1.630000
서울    2.832690
인천    9.818107
dtype: float64
    
# 데이터 추가    
rs['대구'] = 1.41
rs
부산    1.630000
서울    2.832690
인천    9.818107
대구    1.410000
dtype: float64
    
# 데이터 삭제
del rs['부산']
rs
서울    2.832690
인천    9.818107
대구    1.410000
dtype: float64
```

## DataFrame

- DataFram 은 클래스임, Series 도 클래스 대문자로 시작함!

```python
import numpy as np
import pandas as pd
```

### 데이터프레임 생성

- 데이터 프레임은 2차원 모양을 가지고 있음
- 데이터프레임을 만드는 방법은 다양하다. 가장 간단한 방법은 다음과 같다.
  1. 우선 하나의 열이 되는 데이터를 리스트나 일차원 배열을 준비한다.
  2. 이 각각의 열에 대한 이름(라벨)을 키로 가지는 딕셔너리를 만든다.
  3. 이 데이터를 `DataFrame` 클래스 생성자에 넣는다. 동시에 열방향 인덱스는 `columns` 인수로, 행방향 인덱스는 `index` 인수로 지정한다.

```python
data = {
    "2015": [9904312, 3448737, 2890451, 2466052],
    "2010": [9631482, 3393191, 2632035, 2431774],
    "2005": [9762546, 3512547, 2517680, 2456016],
    "2000": [9853972, 3655437, 2466338, 2473990],
    "지역": ["수도권", "경상권", "수도권", "경상권"],
    "2010-2015 증가율": [0.0283, 0.0163, 0.0982, 0.0141]
}
columns = ["지역", "2015", "2010", "2005", "2000", "2010-2015 증가율"]
index = ["서울", "부산", "인천", "대구"]
df = pd.DataFrame(data, index=index, columns=columns)
df

	지역	2015	2010	2005	2000	2010-2015 증가율
서울	수도권	9904312	9631482	9762546	9853972	0.0283
부산	경상권	3448737	3393191	3512547	3655437	0.0163
인천	수도권	2890451	2632035	2517680	2466338	0.0982
대구	경상권	2466052	2431774	2456016	2473990	0.0141
```

- 행인덱스 = index
- 열인덱스 = columns

```python
# 전치
df.T
도시	서울	부산	인천	대구
특성				
지역	수도권	경상권	수도권	경상권
2015	9904312	3448737	2890451	2466052
2010	9631482	3393191	2632035	2431774
2005	9762546	3512547	2517680	2456016
2000	9853972	3655437	2466338	2473990
2010-2015 증가율	0.0283	0.0163	0.0982	0.0141
```

### 열 데이터의 갱신, 추가, 삭제

```python
# 갱신 - 백분율로 변환
df['2010-2015 증가율'] = df['2010-2015 증가율'] * 100
df
특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
서울	수도권	9904312	9631482	9762546	9853972	2.83
부산	경상권	3448737	3393191	3512547	3655437	1.63
인천	수도권	2890451	2632035	2517680	2466338	9.82
대구	경상권	2466052	2431774	2456016	2473990	1.41

# 추가 - 열에 리스트 값을 주면 추가가됨
df['2020'] = [1, 2, 3, 4]
df
특성	지역	2015	2010	2005	2000	2010-2015 증가율	2020
도시							
서울	수도권	9904312	9631482	9762546	9853972	2.83	1
부산	경상권	3448737	3393191	3512547	3655437	1.63	2
인천	수도권	2890451	2632035	2517680	2466338	9.82	3
대구	경상권	2466052	2431774	2456016	2473990	1.41	4

# 삭제 - del['삭제할열'] 열의 인덱스 삭제
del df['2020']
df
특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
서울	수도권	9904312	9631482	9762546	9853972	2.83
부산	경상권	3448737	3393191	3512547	3655437	1.63
인천	수도권	2890451	2632035	2517680	2466338	9.82
대구	경상권	2466052	2431774	2456016	2473990	1.41
```

### 열 인덱싱

```python
type(df['지역']), type(df[['지역']])
(pandas.core.series.Series, pandas.core.frame.DataFrame)
```

- 리스트로 한번더 감싸는 것에 차이, 시리즈와 데이터 프레임

### 행 인덱싱

```python
# 슬라이싱으로 해야만 행이 보임 슬라이싱 없이는 오류
df[:'서울']
특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
서울	수도권	9904312	9631482	9762546	9853972	2.83

df[1:2]
특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
부산	경상권	3448737	3393191	3512547	3655437	1.63

df['부산':'인천']
특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
부산	경상권	3448737	3393191	3512547	3655437	1.63
인천	수도권	2890451	2632035	2517680	2466338	9.82
```

- 행단위로 인덱싱을 하려면 반드시 슬라이싱을 해야 함
- 숫자로 하는것과, 키로 부르는 것의 차이 유의

```python
df.head(3)
특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
서울	수도권	9904312	9631482	9762546	9853972	2.83
부산	경상권	3448737	3393191	3512547	3655437	1.63
인천	수도권	2890451	2632035	2517680	2466338	9.82

df.tail(3)
특성	지역	2015	2010	2005	2000	2010-2015 증가율
도시						
부산	경상권	3448737	3393191	3512547	3655437	1.63
인천	수도권	2890451	2632035	2517680	2466338	9.82
대구	경상권	2466052	2431774	2456016	2473990	1.41
```

- 행인덱싱 보다는 head 와 tail을 많이 사용

### 개별 데이터 인덱싱

- df[\'열이름']\['행이름'] 으로 호출함

```python
df['2015']['서울'], df['2015'][0]
9904312
```

### 데이터 입출력

### CSV파일 출력

### 인터넷 상의 CSV 파일 읽기



### 데이터 프레임 합성

#### merge

- 



