#  [Numpy](https://datascienceschool.net/01%20python/03.01%20%EB%84%98%ED%8C%8C%EC%9D%B4%20%EB%B0%B0%EC%97%B4.html) 배열 프로그래밍

- 배열을 사용해 적은 메모리로 빠르게 많은 데이터 처리를 위함
- 배열과 리스트의 차이
  - 모든 원소가 같은 자료형이어야 한다.
  - 원소의 갯수를 바꿀 수 없다.

## 넘파이 패키지 임포트

```python
import numpy as np
```

## 1차원 배열 만들기

```python
ar = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
ar

>>> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

- np.array([ ])를 이용해 넘파이 어레이를 만들 수 있음 = 1차원 배열

```python
type(ar)
>>>numpy.ndarray
```

- 넘파이로 만들어진 객체를 보면 리스트와 같음
- 리스트, 클래스 객체는 각각 원소가 다른 자료형이 될 수 있음
- 배열의 객체는 C언어의 배열 처럼 연속적인 메모리 배치를 가져 모든 원소가 같은 자료형이어야 함, 때문에 원소에 대한 접근과 반복문 실행이 빨라짐

## 백터화 연산

```python
# 넘파이 계산법
data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
x = np.array(data)
2 * x
>>>array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])

# 리스트 계산법
L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(2 * L)
>>>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

answer = []
for di in data:
    answer.append(2 * di)
answer
>>>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

- 넘파이는 해당 값을 자체적으로 연산할 수 잇음
- 리스트는 넘파이식으로 계산하면 해당 내용이 반복되고, for 문과 같이 반복문을 이용해야 함

```python
# 넘파이의 다양한 계산식
a = np.array([1, 2, 3])
b = np.array([10, 20, 30])

2 * a + b
>>>array([12, 24, 36])

a == 2
>>>array([False,  True, False])

b > 10
>>>array([False,  True,  True])

(a == 2) & (b > 10)
>>>array([False,  True, False])
```

## 2차원 배열 만들기

- 넘파이 배열은 1차원뿐 아닌 2, 3차원의 다차원 배열구조를 지원함.
- 2차원 배열 = 행렬, 가로 : 행(row), 세로 : 열(column)

```python
# 2차원 2 X 3 배열
c = np.array([[0, 1, 2], [3, 4, 5]])  # 2 x 3 array
c
>>>array([[0, 1, 2],
       [3, 4, 5]])

# 행의 갯수
len(c)
>>>2

# 열의 갯수
len(c[0])
>>>3
```

- 연습 문제 1

  넘파이를 사용하여 다음과 같은 행렬을 만든다.

  ```
  10 20 30 40
  50 60 70 80
  ```

```python
import numpy as np

a = np.array([10,20,30,40],[50,60,70,80])

a
>>>array([[10, 20, 30, 40],
       [50, 60, 70, 80]])
```



## 3차원 배열 만들기

- 리스트의 리스트의 리스트 이용하면 3차원 배열 생성 가능

```python
# 2 X 3 X 4 깊이X행X열
d = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]])   # 2 x 3 x 4 array

len(d), len(d[0]), len(d[0][0])
>>>(2, 3, 4)		# 깊이, 행, 열
```



## 배열의 차원과 크기 알아내기

- 배열의 차원 및 크기를 더 간단하게 알아내는 방법
- ndim, shape 속성 이용

```python
d = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]]) 
print(a.ndim)
>>>3	# 배열의 차원
print(a.shape)
>>>(2, 3, 4)  # 배열의 깊이, 행, 열 

a.size

```



## 배열의 인덱싱

```python
# 1차원 인덱싱
a = np.array([0, 1, 2, 3, 4])
a[2]
>>>2
a[-1]
>>>4

# 축(axis)
a = np.array([[0, 1, 2], 
              [3, 4, 5]])

a[0, 0]  # 첫번째 행의 첫번째 열
>>>0

a[-1, -1]  # 마지막 행의 마지막 열
>>>5
```



## 배열 슬라이싱

```python
# 파이썬의 슬라이싱과 ,를 함께 사용
a = np.array([[0, 1, 2, 3], 
              [4, 5, 6, 7]])

a[0, :]  # [행, 열] 첫번째 행 전체
>>>array([0, 1, 2, 3])

a[:, 1]  # 두번째 열 전체
>>>array([1, 5])

a[1, 1:]  # 두번째 행의 두번째 열부터 끝열까지
>>>array([5, 6, 7])

a[:2, :2]
>>>array([[0, 1],
       [4, 5]])
```

```markdown
# 연습 문제 2

다음 행렬과 같은 행렬이 있다.


m = np.array([[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9],
            [10, 11, 12, 13, 14]])


1. 이 행렬에서 값 7 을 인덱싱한다.
m[1,2]
2. 이 행렬에서 값 14 을 인덱싱한다.
m[2,-1]
3. 이 행렬에서 배열 [6, 7] 을 슬라이싱한다.
m[1,1:3]
4. 이 행렬에서 배열 [7, 12] 을 슬라이싱한다.
m[1:3, 2]
5. 이 행렬에서 배열 [[3, 4], [8, 9]] 을 슬라이싱한다.
m[:2,-2:]
```

## 배열 인덱싱

- 팬시 인덱싱(fancy indexing) : 배열인덱싱 방법

```python
# 짝수만 출력하는 방법, 불리언 배열방식
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
idx = np.array([True, False, True, False, True,
               False, True, False, True, False])
a[idx]
>>>array([0, 2, 4, 6, 8])

# 조건식으로 짝수만 출력하기
a[a % 2 == 0]
>>>array([0, 2, 4, 6, 8])
```



- 정수 배열 인덱싱 : 인덱스를 이용해 출력

```python
# 홀수 인덱스만 출력
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 2, 4, 6, 8])
a[idx]
>>>array([11, 33, 55, 77, 99])

# 인덱스 번호 호출
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2])
a[idx]
>>>array([11, 11, 11, 11, 11, 11, 22, 22, 22, 22, 22, 33, 33, 33, 33, 33])

# 3차원 배열 인덱싱
a = np.array([[1, 2, 3, 4], 
              [5, 6, 7, 8], 
              [9, 10, 11, 12]])

# 불
a[:, [True, False, False, True]]
>>>array([[ 1,  4],
       [ 5,  8],
       [ 9, 12]])

# 행 순서 변경
a[[2, 0, 1], :]
>>>array([[ 9, 10, 11, 12],
       [ 1,  2,  3,  4],
       [ 5,  6,  7,  8]])
```

```markdown
# 연습 문제 3

다음 행렬과 같은 배열이 있다.


x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
             11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

1. 이 배열에서 3의 배수를 찾아라.
x[x % 3 == 0]
2. 이 배열에서 4로 나누면 1이 남는 수를 찾아라.
x[x % 4 == 1]
3. 이 배열에서 3으로 나누면 나누어지고 4로 나누면 1이 남는 수를 찾아라.
x1 = x[x % 3 == 0]
x1[x1%4 == 1]
```

## 배열의 생성과 변형

- 넘파이의 자료형

```python
# dtype 으로 속성 확인하기
x = np.array([1, 2, 3])
x.dtype
>>>dtype('int64')

x = np.array([1.0, 2.0, 3.0])
x.dtype
>>>dtype('float64')

x = np.array([1, 2, 3.0])
x.dtype
>>>dtype('float64')
```

- np의 속성은 모두 동일함

```python
# dtype= 으로 속성을 부여 할 수 있음
x = np.array([1, 2, 3], dtype='f')
x.dtype
>>>dtype('float32')
```

| dtype 접두사 | 설명            | 사용 예                  |
| ------------ | --------------- | ------------------------ |
| `b`          | 불리언          | `b` (참 혹은 거짓)       |
| `i`          | 정수            | `i8` (64비트)            |
| `u`          | 부호 없는 정수  | `u8` (64비트)            |
| `f`          | 부동소수점      | `f8` (64비트)            |
| `c`          | 복소 부동소수점 | `c16` (128비트)          |
| `O`          | 객체            | `0` (객체에 대한 포인터) |
| `S`          | 바이트 문자열   | `S24` (24 글자)          |
| `U`          | 유니코드 문자열 | `U24` (24 유니코드 글자) |

## Inf와 NaN

- np.inf(infinity) : 넘파이에서 무한대를 표현
- np.NaN(not a number) : 정의할 수 없는 숫자를 나타냄

```python
np.array([0, 1, -1, 0]) / np.array([1, 0, 0, 0])
>>>array([  0.,  inf, -inf,  nan])

np.log(0)
>>>-inf

np.exp(-np.inf)
>>>0.0
```



## 배열 생성

- `zeros`, `ones`
- `zeros_like`, `ones_like`
- `empty`
- `arange`
- `linspace`, `logspace`

```python
# zeros 활용해 크기가 정해져 있고, 모든 값이 0인 배열 생성
a = np.zeros(5)
a
>>>array([0., 0., 0., 0., 0.])

# 튜플에도 적용 가능
b = np.zeros((2, 3))
b
>>>array([[0., 0., 0.],
       [0., 0., 0.]])

# dtype으로 인수 명시하여 해당 자료형 원소배열 생성 가능
c = np.zeros((5, 2), dtype="i")
c
>>>array([[0, 0],
       [0, 0],
       [0, 0],
       [0, 0],
       [0, 0]], dtype=int32)

# ones 활용 1로 초기화된 배열 생성
e = np.ones((2, 3, 4), dtype="i8")
e
>>>array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]])

# _likes 활용하여 다른 배열과 같은크기의 배열 생성가능
f = np.ones_like(b, dtype="f")
f
>>>array([[1., 1., 1.],
       [1., 1., 1.]], dtype=float32)

# empty 활용하여 배열을 생성만하고 특정한 값으로 초기화 하지 않기
g = np.empty((4, 3))
g
>>>array([[6.94820328e-310, 4.67533915e-310, 5.28964691e+180],
       [6.01346953e-154, 4.81809028e+233, 7.86517465e+276],
       [6.01346953e-154, 2.58408173e+161, 2.46600381e-154],
       [2.47379808e-091, 4.47593816e-091, 6.01347002e-154]])
```

- arange : 넘파이의 range 명령과 같음

```python
np.arange(10)  # 0 .. n-1
>>>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

- `linspace` 명령이나 `logspace` 명령은 선형 구간 혹은 로그 구간을 지정한 구간의 수만큼 분할한다.

```python
np.linspace(0, 100, 5)  # 시작, 끝(포함), 갯수
>>>array([  0.,  25.,  50.,  75., 100.])

np.logspace(0.1, 1, 10)
>>>array([ 1.25892541,  1.58489319,  1.99526231,  2.51188643,  3.16227766,
        3.98107171,  5.01187234,  6.30957344,  7.94328235, 10.        ])
```

## 전치 연산

- 2차원 배열의 전치(transpose) 연산은 행과 열을 바꾸는 작업

```python
# T
A = np.array([[1, 2, 3], [4, 5, 6]])
A
>>>array([[1, 2, 3],
       [4, 5, 6]])

A.T
>>>array([[1, 4],
       [2, 5],
       [3, 6]])
```

## 배열의 크기 변형

- reshape : 만들어진 배열의 내부 데이터를 보존한 채로 형태만 바꾸는 명령어

```python
a = np.arange(12)
a
>>>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
# a.reshape(행,열)
b = a.reshape(3, 4)
b
>>>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

# -1 값으로 자동 계산됨
a.reshape(3, -1)
>>>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

# 3차원 (깊이, 행, 열)
a.reshape(2, 2, -1)
>>>array([[[ 0,  1,  2],
        [ 3,  4,  5]],

       [[ 6,  7,  8],
        [ 9, 10, 11]]])
```

- flatten, ravel : 다차원의 배열을 1차원으로 변경

```python
a.flatten()
>>>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

a.ravel()
>>>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

```

- newaxis : 같은 배열에 대해 차원을 1차원 증가시킬 경우

``` python
x[:, np.newaxis]
>>>array([[0],
       [1],
       [2],
       [3],
       [4]])
```

## 배열 연결

- `hstack` : 행의 수가 같은 두 개 이상의 배열을 옆으로 연결하여 열의 수가 더 많은 배열을 만듬

```python
# hstack
a1 = np.ones((2, 3))
a1
>>>array([[1., 1., 1.],
       [1., 1., 1.]])

a2 = np.zeros((2, 2))
a2
array([[0., 0.],
       [0., 0.]])
# np.hstack([a,b])
np.hstack([a1, a2])
>>>array([[1., 1., 1., 0., 0.],
       [1., 1., 1., 0., 0.]])
```

`vstack` : 열의 수가 같은 두 개 이상의 배열을 위아래로 연결하여 행의 수가 더 많은 배열을 만듬

```python
# vstack
b1 = np.ones((2, 3))
b1
>>>array([[1., 1., 1.],
       [1., 1., 1.]])

b2 = np.zeros((3, 3))
b2
>>>array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])

np.vstack([b1, b2])
>>>array([[1., 1., 1.],
       [1., 1., 1.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
```

`dstack` : 제3의 축 즉, 행이나 열이 아닌 깊이(depth) 방향으로 배열을 합친다. 가장 안쪽의 원소의 차원이 증가한다.

```python
# dstack : 이 예제의 경우에는 shape 변화가 2개의 (3 x 4) -> 1개의 (3 x 4 x 2)가 된다.

c1 = np.ones((3, 4))
c1
>>>array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])

c2 = np.zeros((3, 4))
c2
>>>array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

np.dstack([c1, c2])
>>>array([[[1., 0.],
        [1., 0.],
        [1., 0.],
        [1., 0.]],

       [[1., 0.],
        [1., 0.],
        [1., 0.],
        [1., 0.]],

       [[1., 0.],
        [1., 0.],
        [1., 0.],
        [1., 0.]]])

(np.dstack([c1, c2])).shape
>>>(3, 4, 2)
```

- `stack` : `dstack`의 기능을 확장한 것으로 `dstack`처럼 마지막 차원으로 연결하는 것이 아니라 사용자가 지정한 차원(축으로) 배열을 연결한다.`axis` 인수(디폴트 0)를 사용하여 연결후의 회전 방향을 정한다. 디폴트 인수값은 0이고 가장 앞쪽에 차원이 생성된다. 즉, 배열 두 개가 겹치게 되므로 연결하고자 하는 배열들의 크기가 모두 같아야 한다.

```python
# 다음 예에서는 axis=0 이므로 가장 바깥에 값이 2인 차원이 추가된다. 
# 즉, shape 변화는 2개의 (3 x 4) -> 1개의 (2 x 3 x 4) 이다.
c = np.stack([c1, c2])
c
>>>array([[[1., 1., 1., 1.],
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]],

       [[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]]])

c.shape
>>>(2, 3, 4)

c = np.stack([c1, c2], axis=1)
c
>>>array([[[1., 1., 1., 1.],
        [0., 0., 0., 0.]],

       [[1., 1., 1., 1.],
        [0., 0., 0., 0.]],

       [[1., 1., 1., 1.],
        [0., 0., 0., 0.]]])
```

- `r_` :`hstack` 명령과 비슷하게 배열을 좌우로 연결한다. 다만 메서드임에도 불구하고 소괄호(parenthesis, `()`)를 사용하지 않고 인덱싱과 같이 대괄호(bracket, `[]`)를 사용한다. 이런 특수 메서드를 인덱서(indexer)라고 한다.

```python
np.r_[np.array([1, 2, 3]), np.array([4, 5, 6])]
>>>array([1, 2, 3, 4, 5, 6])
```

- `c_` : 배열의 차원을 증가시킨 후 좌우로 연결한다. 만약 1차원 배열을 연결하면 2차원 배열이 된다.

```python
np.c_[np.array([1, 2, 3]), np.array([4, 5, 6])]
>>>array([[1, 4],
       [2, 5],
       [3, 6]])
```

- `tile` : 명령은 동일한 배열을 반복하여 연결한다.

```python
a = np.array([[0, 1, 2], [3, 4, 5]])
np.tile(a, 2)
>>>array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])

# 
np.tile(a, (3, 2))
>>>array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5],
       [0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5],
       [0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])
```

`````markdown
````
연습 문제 3.2.1

지금까지 공부한 명령어를 사용하여 다음과 같은 배열을 만들어라.

```
array([[   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [  10.,   20.,   30.,   40.,   50.],
       [  60.,   70.,   80.,   90.,  100.],
       [ 110.,  120.,  130.,  140.,  150.],
       [   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [  10.,   20.,   30.,   40.,   50.],
       [  60.,   70.,   80.,   90.,  100.],
       [ 110.,  120.,  130.,  140.,  150.]])
```
````
`````

```python
a = np.zeros((3,3))
b = np.ones((3,2))
c = np.arange(10,51,10)
d = np.arange(60,101,10)
e = np.arange(110, 151,10)

f = np.hstack([a,b])

g = np.vstack([f,c,d,e])
h = np.vstack([g,g])
h
>>>array([[  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [ 10.,  20.,  30.,  40.,  50.],
       [ 60.,  70.,  80.,  90., 100.],
       [110., 120., 130., 140., 150.],
       [  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [ 10.,  20.,  30.,  40.,  50.],
       [ 60.,  70.,  80.,  90., 100.],
       [110., 120., 130., 140., 150.]])
```

## 2차원 그리드 포인트 생성

- `meshgrid` 명령은 사각형 영역을 구성하는 가로축의 점들과 세로축의 점을 나타내는 두 벡터를 인수로 받아서 이 사각형 영역을 이루는 조합을 출력한다. 결과는 그리드 포인트의 x 값만을 표시하는 행렬과 y 값만을 표시하는 행렬 두 개로 분리하여 출력한다.

```python
x = np.arange(3)
x
>>>array([0, 1, 2])

y = np.arange(5)
y
>>>array([0, 1, 2, 3, 4])

X, Y = np.meshgrid(x, y)

X
>>>array([[0, 1, 2],
       [0, 1, 2],
       [0, 1, 2],
       [0, 1, 2],
       [0, 1, 2]])

Y
>>>array([[0, 0, 0],
       [1, 1, 1],
       [2, 2, 2],
       [3, 3, 3],
       [4, 4, 4]])

[list(zip(x, y)) for x, y in zip(X, Y)]
>>>[[(0, 0), (1, 0), (2, 0)],
 [(0, 1), (1, 1), (2, 1)],
 [(0, 2), (1, 2), (2, 2)],
 [(0, 3), (1, 3), (2, 3)],
 [(0, 4), (1, 4), (2, 4)]]
```

## 배열의 연산

## 백터화 연산

- 벡터화 연산을 쓰면 명시적으로 반복문을 사용하지 않고도 배열의 모든 원소에 대해 반복연산을 할 수 있다. 

```py

```



















