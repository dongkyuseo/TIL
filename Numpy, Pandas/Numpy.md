#  [Numpy](https://datascienceschool.net/01%20python/03.01%20%EB%84%98%ED%8C%8C%EC%9D%B4%20%EB%B0%B0%EC%97%B4.html) 배열 프로그래밍

- 배열을 사용해 적은 메모리로 빠르게 많은 데이터 처리를 위함
- 배열과 리스트의 차이
  - 모든 원소가 같은 자료형이어야 한다.
  - 원소의 갯수를 바꿀 수 없다.

## 넘파이 패키지 임포트

```python
import numpy as np
```

## 1차원 배열 만들기

```python
ar = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
ar

>>> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

- np.array([ ])를 이용해 넘파이 어레이를 만들 수 있음 = 1차원 배열

```python
type(ar)
>>>numpy.ndarray
```

- 넘파이로 만들어진 객체를 보면 리스트와 같음
- 리스트, 클래스 객체는 각각 원소가 다른 자료형이 될 수 있음
- 배열의 객체는 C언어의 배열 처럼 연속적인 메모리 배치를 가져 모든 원소가 같은 자료형이어야 함, 때문에 원소에 대한 접근과 반복문 실행이 빨라짐

## 백터화 연산

```python
# 넘파이 계산법
data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
x = np.array(data)
2 * x
>>>array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])

# 리스트 계산법
L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(2 * L)
>>>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

answer = []
for di in data:
    answer.append(2 * di)
answer
>>>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

- 넘파이는 해당 값을 자체적으로 연산할 수 잇음
- 리스트는 넘파이식으로 계산하면 해당 내용이 반복되고, for 문과 같이 반복문을 이용해야 함

```python
# 넘파이의 다양한 계산식
a = np.array([1, 2, 3])
b = np.array([10, 20, 30])

2 * a + b
>>>array([12, 24, 36])

a == 2
>>>array([False,  True, False])

b > 10
>>>array([False,  True,  True])

(a == 2) & (b > 10)
>>>array([False,  True, False])
```

## 2차원 배열 만들기

- 넘파이 배열은 1차원뿐 아닌 2, 3차원의 다차원 배열구조를 지원함.
- 2차원 배열 = 행렬, 가로 : 행(row), 세로 : 열(column)

```python
# 2차원 2 X 3 배열
c = np.array([[0, 1, 2], [3, 4, 5]])  # 2 x 3 array
c
>>>array([[0, 1, 2],
       [3, 4, 5]])

# 행의 갯수
len(c)
>>>2

# 열의 갯수
len(c[0])
>>>3
```

- 연습 문제 1

  넘파이를 사용하여 다음과 같은 행렬을 만든다.

  ```
  10 20 30 40
  50 60 70 80
  ```

```python
import numpy as np

a = np.array([10,20,30,40],[50,60,70,80])

a
>>>array([[10, 20, 30, 40],
       [50, 60, 70, 80]])
```



## 3차원 배열 만들기

- 리스트의 리스트의 리스트 이용하면 3차원 배열 생성 가능

```python
# 2 X 3 X 4 깊이X행X열
d = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]])   # 2 x 3 x 4 array

len(d), len(d[0]), len(d[0][0])
>>>(2, 3, 4)		# 깊이, 행, 열
```



## 배열의 차원과 크기 알아내기

- 배열의 차원 및 크기를 더 간단하게 알아내는 방법
- ndim, shape 속성 이용

```python
d = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]]) 
print(a.ndim)
>>>3	# 배열의 차원
print(a.shape)
>>>(2, 3, 4)  # 배열의 깊이, 행, 열 

a.size

```



## 배열의 인덱싱

```python
# 1차원 인덱싱
a = np.array([0, 1, 2, 3, 4])
a[2]
>>>2
a[-1]
>>>4

# 축(axis)
a = np.array([[0, 1, 2], 
              [3, 4, 5]])

a[0, 0]  # 첫번째 행의 첫번째 열
>>>0

a[-1, -1]  # 마지막 행의 마지막 열
>>>5
```



## 배열 슬라이싱

```python
# 파이썬의 슬라이싱과 ,를 함께 사용
a = np.array([[0, 1, 2, 3], 
              [4, 5, 6, 7]])

a[0, :]  # [행, 열] 첫번째 행 전체
>>>array([0, 1, 2, 3])

a[:, 1]  # 두번째 열 전체
>>>array([1, 5])

a[1, 1:]  # 두번째 행의 두번째 열부터 끝열까지
>>>array([5, 6, 7])

a[:2, :2]
>>>array([[0, 1],
       [4, 5]])
```

```markdown
# 연습 문제 2

다음 행렬과 같은 행렬이 있다.


m = np.array([[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9],
            [10, 11, 12, 13, 14]])


1. 이 행렬에서 값 7 을 인덱싱한다.
m[1,2]
2. 이 행렬에서 값 14 을 인덱싱한다.
m[2,-1]
3. 이 행렬에서 배열 [6, 7] 을 슬라이싱한다.
m[1,1:3]
4. 이 행렬에서 배열 [7, 12] 을 슬라이싱한다.
m[1:3, 2]
5. 이 행렬에서 배열 [[3, 4], [8, 9]] 을 슬라이싱한다.
m[:2,-2:]
```

## 배열 인덱싱

- 팬시 인덱싱(fancy indexing) : 배열인덱싱 방법

```python
# 짝수만 출력하는 방법, 불리언 배열방식
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
idx = np.array([True, False, True, False, True,
               False, True, False, True, False])
a[idx]
>>>array([0, 2, 4, 6, 8])

# 조건식으로 짝수만 출력하기
a[a % 2 == 0]
>>>array([0, 2, 4, 6, 8])
```



- 정수 배열 인덱싱 : 인덱스를 이용해 출력

```python
# 홀수 인덱스만 출력
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 2, 4, 6, 8])
a[idx]
>>>array([11, 33, 55, 77, 99])

# 인덱스 번호 호출
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2])
a[idx]
>>>array([11, 11, 11, 11, 11, 11, 22, 22, 22, 22, 22, 33, 33, 33, 33, 33])

# 3차원 배열 인덱싱
a = np.array([[1, 2, 3, 4], 
              [5, 6, 7, 8], 
              [9, 10, 11, 12]])

# 불
a[:, [True, False, False, True]]
>>>array([[ 1,  4],
       [ 5,  8],
       [ 9, 12]])

# 행 순서 변경
a[[2, 0, 1], :]
>>>array([[ 9, 10, 11, 12],
       [ 1,  2,  3,  4],
       [ 5,  6,  7,  8]])
```

```markdown
# 연습 문제 3

다음 행렬과 같은 배열이 있다.


x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
             11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

1. 이 배열에서 3의 배수를 찾아라.
x[x % 3 == 0]
2. 이 배열에서 4로 나누면 1이 남는 수를 찾아라.
x[x % 4 == 1]
3. 이 배열에서 3으로 나누면 나누어지고 4로 나누면 1이 남는 수를 찾아라.
x1 = x[x % 3 == 0]
x1[x1%4 == 1]
```





























