#  [Numpy](https://datascienceschool.net/01%20python/03.01%20%EB%84%98%ED%8C%8C%EC%9D%B4%20%EB%B0%B0%EC%97%B4.html) 배열 프로그래밍

- 배열을 사용해 적은 메모리로 빠르게 많은 데이터 처리를 위함
- 배열과 리스트의 차이
  - 모든 원소가 같은 자료형이어야 한다.
  - 원소의 갯수를 바꿀 수 없다.



## 넘파이 패키지 임포트

```python
import numpy as np
```



## 1차원 배열 만들기

```python
ar = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
ar

>>> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

- np.array([ ])를 이용해 넘파이 어레이를 만들 수 있음 = 1차원 배열

```python
type(ar)
>>>numpy.ndarray
```

- 넘파이로 만들어진 객체를 보면 리스트와 같음
- 리스트, 클래스 객체는 각각 원소가 다른 자료형이 될 수 있음
- 배열의 객체는 C언어의 배열 처럼 연속적인 메모리 배치를 가져 모든 원소가 같은 자료형이어야 함, 때문에 원소에 대한 접근과 반복문 실행이 빨라짐



## 백터화 연산

```python
# 넘파이 계산법
data = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
x = np.array(data)
2 * x
>>>array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])

# 리스트 계산법
L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(2 * L)
>>>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

answer = []
for di in data:
    answer.append(2 * di)
answer
>>>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

- 넘파이는 해당 값을 자체적으로 연산할 수 잇음
- 리스트는 넘파이식으로 계산하면 해당 내용이 반복되고, for 문과 같이 반복문을 이용해야 함

```python
# 넘파이의 다양한 계산식
a = np.array([1, 2, 3])
b = np.array([10, 20, 30])

2 * a + b
>>>array([12, 24, 36])

a == 2
>>>array([False,  True, False])

b > 10
>>>array([False,  True,  True])

(a == 2) & (b > 10)
>>>array([False,  True, False])
```



## 2차원 배열 만들기

- 넘파이 배열은 1차원뿐 아닌 2, 3차원의 다차원 배열구조를 지원함.
- 2차원 배열 = 행렬, 가로 : 행(row), 세로 : 열(column)

```python
# 2차원 2 X 3 배열
c = np.array([[0, 1, 2], [3, 4, 5]])  # 2 x 3 array
c
>>>array([[0, 1, 2],
       [3, 4, 5]])

# 행의 갯수
len(c)
>>>2

# 열의 갯수
len(c[0])
>>>3
```

- 연습 문제 1

  넘파이를 사용하여 다음과 같은 행렬을 만든다.

  ```
  10 20 30 40
  50 60 70 80
  ```

```python
import numpy as np

a = np.array([10,20,30,40],[50,60,70,80])

a
>>>array([[10, 20, 30, 40],
       [50, 60, 70, 80]])
```



## 3차원 배열 만들기

- 리스트의 리스트의 리스트 이용하면 3차원 배열 생성 가능

```python
# 2 X 3 X 4 깊이X행X열
d = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]])   # 2 x 3 x 4 array

len(d), len(d[0]), len(d[0][0])
>>>(2, 3, 4)		# 깊이, 행, 열
```



## 배열의 차원과 크기 알아내기

- 배열의 차원 및 크기를 더 간단하게 알아내는 방법
- ndim, shape 속성 이용

```python
d = np.array([[[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]],
              [[11, 12, 13, 14],
               [15, 16, 17, 18],
               [19, 20, 21, 22]]]) 
print(a.ndim)
>>>3	# 배열의 차원
print(a.shape)
>>>(2, 3, 4)  # 배열의 깊이, 행, 열 

a.size

```



## 배열의 인덱싱

```python
# 1차원 인덱싱
a = np.array([0, 1, 2, 3, 4])
a[2]
>>>2
a[-1]
>>>4

# 축(axis)
a = np.array([[0, 1, 2], 
              [3, 4, 5]])

a[0, 0]  # 첫번째 행의 첫번째 열
>>>0

a[-1, -1]  # 마지막 행의 마지막 열
>>>5
```



## 배열 슬라이싱

```python
# 파이썬의 슬라이싱과 ,를 함께 사용
a = np.array([[0, 1, 2, 3], 
              [4, 5, 6, 7]])

a[0, :]  # [행, 열] 첫번째 행 전체
>>>array([0, 1, 2, 3])

a[:, 1]  # 두번째 열 전체
>>>array([1, 5])

a[1, 1:]  # 두번째 행의 두번째 열부터 끝열까지
>>>array([5, 6, 7])

a[:2, :2]
>>>array([[0, 1],
       [4, 5]])
```

```markdown
# 연습 문제 2

다음 행렬과 같은 행렬이 있다.


m = np.array([[ 0,  1,  2,  3,  4],
            [ 5,  6,  7,  8,  9],
            [10, 11, 12, 13, 14]])


1. 이 행렬에서 값 7 을 인덱싱한다.
m[1,2]
2. 이 행렬에서 값 14 을 인덱싱한다.
m[2,-1]
3. 이 행렬에서 배열 [6, 7] 을 슬라이싱한다.
m[1,1:3]
4. 이 행렬에서 배열 [7, 12] 을 슬라이싱한다.
m[1:3, 2]
5. 이 행렬에서 배열 [[3, 4], [8, 9]] 을 슬라이싱한다.
m[:2,-2:]
```



## 배열 인덱싱

- 팬시 인덱싱(fancy indexing) : 배열인덱싱 방법

```python
# 짝수만 출력하는 방법, 불리언 배열방식
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
idx = np.array([True, False, True, False, True,
               False, True, False, True, False])
a[idx]
>>>array([0, 2, 4, 6, 8])

# 조건식으로 짝수만 출력하기
a[a % 2 == 0]
>>>array([0, 2, 4, 6, 8])
```



- 정수 배열 인덱싱 : 인덱스를 이용해 출력

```python
# 홀수 인덱스만 출력
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 2, 4, 6, 8])
a[idx]
>>>array([11, 33, 55, 77, 99])

# 인덱스 번호 호출
a = np.array([11, 22, 33, 44, 55, 66, 77, 88, 99])
idx = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2])
a[idx]
>>>array([11, 11, 11, 11, 11, 11, 22, 22, 22, 22, 22, 33, 33, 33, 33, 33])

# 3차원 배열 인덱싱
a = np.array([[1, 2, 3, 4], 
              [5, 6, 7, 8], 
              [9, 10, 11, 12]])

# 불
a[:, [True, False, False, True]]
>>>array([[ 1,  4],
       [ 5,  8],
       [ 9, 12]])

# 행 순서 변경
a[[2, 0, 1], :]
>>>array([[ 9, 10, 11, 12],
       [ 1,  2,  3,  4],
       [ 5,  6,  7,  8]])
```

```markdown
# 연습 문제 3

다음 행렬과 같은 배열이 있다.


x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
             11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

1. 이 배열에서 3의 배수를 찾아라.
x[x % 3 == 0]
2. 이 배열에서 4로 나누면 1이 남는 수를 찾아라.
x[x % 4 == 1]
3. 이 배열에서 3으로 나누면 나누어지고 4로 나누면 1이 남는 수를 찾아라.
x1 = x[x % 3 == 0]
x1[x1%4 == 1]
```



## 배열의 생성과 변형

- 넘파이의 자료형

```python
# dtype 으로 속성 확인하기
x = np.array([1, 2, 3])
x.dtype
>>>dtype('int64')

x = np.array([1.0, 2.0, 3.0])
x.dtype
>>>dtype('float64')

x = np.array([1, 2, 3.0])
x.dtype
>>>dtype('float64')
```

- np의 속성은 모두 동일함

```python
# dtype= 으로 속성을 부여 할 수 있음
x = np.array([1, 2, 3], dtype='f')
x.dtype
>>>dtype('float32')
```

| dtype 접두사 | 설명            | 사용 예                  |
| ------------ | --------------- | ------------------------ |
| `b`          | 불리언          | `b` (참 혹은 거짓)       |
| `i`          | 정수            | `i8` (64비트)            |
| `u`          | 부호 없는 정수  | `u8` (64비트)            |
| `f`          | 부동소수점      | `f8` (64비트)            |
| `c`          | 복소 부동소수점 | `c16` (128비트)          |
| `O`          | 객체            | `0` (객체에 대한 포인터) |
| `S`          | 바이트 문자열   | `S24` (24 글자)          |
| `U`          | 유니코드 문자열 | `U24` (24 유니코드 글자) |



## Inf와 NaN

- np.inf(infinity) : 넘파이에서 무한대를 표현
- np.NaN(not a number) : 정의할 수 없는 숫자를 나타냄

```python
np.array([0, 1, -1, 0]) / np.array([1, 0, 0, 0])
>>>array([  0.,  inf, -inf,  nan])

np.log(0)
>>>-inf

np.exp(-np.inf)
>>>0.0
```



## 배열 생성

- `zeros`, `ones`
- `zeros_like`, `ones_like`
- `empty`
- `arange`
- `linspace`, `logspace`

```python
# zeros 활용해 크기가 정해져 있고, 모든 값이 0인 배열 생성
a = np.zeros(5)
a
>>>array([0., 0., 0., 0., 0.])

# 튜플에도 적용 가능
b = np.zeros((2, 3))
b
>>>array([[0., 0., 0.],
       [0., 0., 0.]])

# dtype으로 인수 명시하여 해당 자료형 원소배열 생성 가능
c = np.zeros((5, 2), dtype="i")
c
>>>array([[0, 0],
       [0, 0],
       [0, 0],
       [0, 0],
       [0, 0]], dtype=int32)

# ones 활용 1로 초기화된 배열 생성
e = np.ones((2, 3, 4), dtype="i8")
e
>>>array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],

       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]])

# _likes 활용하여 다른 배열과 같은크기의 배열 생성가능
f = np.ones_like(b, dtype="f")
f
>>>array([[1., 1., 1.],
       [1., 1., 1.]], dtype=float32)

# empty 활용하여 배열을 생성만하고 특정한 값으로 초기화 하지 않기
g = np.empty((4, 3))
g
>>>array([[6.94820328e-310, 4.67533915e-310, 5.28964691e+180],
       [6.01346953e-154, 4.81809028e+233, 7.86517465e+276],
       [6.01346953e-154, 2.58408173e+161, 2.46600381e-154],
       [2.47379808e-091, 4.47593816e-091, 6.01347002e-154]])
```

- arange : 넘파이의 range 명령과 같음

```python
np.arange(10)  # 0 .. n-1
>>>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

- `linspace` 명령이나 `logspace` 명령은 선형 구간 혹은 로그 구간을 지정한 구간의 수만큼 분할한다.

```python
np.linspace(0, 100, 5)  # 시작, 끝(포함), 갯수
>>>array([  0.,  25.,  50.,  75., 100.])

np.logspace(0.1, 1, 10)
>>>array([ 1.25892541,  1.58489319,  1.99526231,  2.51188643,  3.16227766,
        3.98107171,  5.01187234,  6.30957344,  7.94328235, 10.        ])
```



## 전치 연산

- 2차원 배열의 전치(transpose) 연산은 행과 열을 바꾸는 작업

```python
# T
A = np.array([[1, 2, 3], [4, 5, 6]])
A
>>>array([[1, 2, 3],
       [4, 5, 6]])

A.T
>>>array([[1, 4],
       [2, 5],
       [3, 6]])
```



## 배열의 크기 변형

- reshape : 만들어진 배열의 내부 데이터를 보존한 채로 형태만 바꾸는 명령어

```python
a = np.arange(12)
a
>>>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
# a.reshape(행,열)
b = a.reshape(3, 4)
b
>>>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

# -1 값으로 자동 계산됨
a.reshape(3, -1)
>>>array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

# 3차원 (깊이, 행, 열)
a.reshape(2, 2, -1)
>>>array([[[ 0,  1,  2],
        [ 3,  4,  5]],

       [[ 6,  7,  8],
        [ 9, 10, 11]]])
```

- flatten, ravel : 다차원의 배열을 1차원으로 변경

```python
a.flatten()
>>>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

a.ravel()
>>>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

```

- newaxis : 같은 배열에 대해 차원을 1차원 증가시킬 경우

``` python
x[:, np.newaxis]
>>>array([[0],
       [1],
       [2],
       [3],
       [4]])
```



## 배열 연결

- `hstack` : 행의 수가 같은 두 개 이상의 배열을 옆으로 연결하여 열의 수가 더 많은 배열을 만듬

```python
# hstack
a1 = np.ones((2, 3))
a1
>>>array([[1., 1., 1.],
       [1., 1., 1.]])

a2 = np.zeros((2, 2))
a2
array([[0., 0.],
       [0., 0.]])
# np.hstack([a,b])
np.hstack([a1, a2])
>>>array([[1., 1., 1., 0., 0.],
       [1., 1., 1., 0., 0.]])
```

`vstack` : 열의 수가 같은 두 개 이상의 배열을 위아래로 연결하여 행의 수가 더 많은 배열을 만듬

```python
# vstack
b1 = np.ones((2, 3))
b1
>>>array([[1., 1., 1.],
       [1., 1., 1.]])

b2 = np.zeros((3, 3))
b2
>>>array([[0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])

np.vstack([b1, b2])
>>>array([[1., 1., 1.],
       [1., 1., 1.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
```

`dstack` : 제3의 축 즉, 행이나 열이 아닌 깊이(depth) 방향으로 배열을 합친다. 가장 안쪽의 원소의 차원이 증가한다.

```python
# dstack : 이 예제의 경우에는 shape 변화가 2개의 (3 x 4) -> 1개의 (3 x 4 x 2)가 된다.

c1 = np.ones((3, 4))
c1
>>>array([[1., 1., 1., 1.],
       [1., 1., 1., 1.],
       [1., 1., 1., 1.]])

c2 = np.zeros((3, 4))
c2
>>>array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

np.dstack([c1, c2])
>>>array([[[1., 0.],
        [1., 0.],
        [1., 0.],
        [1., 0.]],

       [[1., 0.],
        [1., 0.],
        [1., 0.],
        [1., 0.]],

       [[1., 0.],
        [1., 0.],
        [1., 0.],
        [1., 0.]]])

(np.dstack([c1, c2])).shape
>>>(3, 4, 2)
```

- `stack` : `dstack`의 기능을 확장한 것으로 `dstack`처럼 마지막 차원으로 연결하는 것이 아니라 사용자가 지정한 차원(축으로) 배열을 연결한다.`axis` 인수(디폴트 0)를 사용하여 연결후의 회전 방향을 정한다. 디폴트 인수값은 0이고 가장 앞쪽에 차원이 생성된다. 즉, 배열 두 개가 겹치게 되므로 연결하고자 하는 배열들의 크기가 모두 같아야 한다.

```python
# 다음 예에서는 axis=0 이므로 가장 바깥에 값이 2인 차원이 추가된다. 
# 즉, shape 변화는 2개의 (3 x 4) -> 1개의 (2 x 3 x 4) 이다.
c = np.stack([c1, c2])
c
>>>array([[[1., 1., 1., 1.],
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]],

       [[0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.]]])

c.shape
>>>(2, 3, 4)

c = np.stack([c1, c2], axis=1)
c
>>>array([[[1., 1., 1., 1.],
        [0., 0., 0., 0.]],

       [[1., 1., 1., 1.],
        [0., 0., 0., 0.]],

       [[1., 1., 1., 1.],
        [0., 0., 0., 0.]]])
```

- `r_` :`hstack` 명령과 비슷하게 배열을 좌우로 연결한다. 다만 메서드임에도 불구하고 소괄호(parenthesis, `()`)를 사용하지 않고 인덱싱과 같이 대괄호(bracket, `[]`)를 사용한다. 이런 특수 메서드를 인덱서(indexer)라고 한다.

```python
np.r_[np.array([1, 2, 3]), np.array([4, 5, 6])]
>>>array([1, 2, 3, 4, 5, 6])
```

- `c_` : 배열의 차원을 증가시킨 후 좌우로 연결한다. 만약 1차원 배열을 연결하면 2차원 배열이 된다.

```python
np.c_[np.array([1, 2, 3]), np.array([4, 5, 6])]
>>>array([[1, 4],
       [2, 5],
       [3, 6]])
```

- `tile` : 명령은 동일한 배열을 반복하여 연결한다.

```python
a = np.array([[0, 1, 2], [3, 4, 5]])
np.tile(a, 2)
>>>array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])

# 
np.tile(a, (3, 2))
>>>array([[0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5],
       [0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5],
       [0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5]])
```

`````markdown
````
연습 문제 3.2.1

지금까지 공부한 명령어를 사용하여 다음과 같은 배열을 만들어라.

```
array([[   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [  10.,   20.,   30.,   40.,   50.],
       [  60.,   70.,   80.,   90.,  100.],
       [ 110.,  120.,  130.,  140.,  150.],
       [   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [   0.,    0.,    0.,    1.,    1.],
       [  10.,   20.,   30.,   40.,   50.],
       [  60.,   70.,   80.,   90.,  100.],
       [ 110.,  120.,  130.,  140.,  150.]])
```
````
`````

```python
a = np.zeros((3,3))
b = np.ones((3,2))
c = np.arange(10,51,10)
d = np.arange(60,101,10)
e = np.arange(110, 151,10)

f = np.hstack([a,b])

g = np.vstack([f,c,d,e])
h = np.vstack([g,g])
h
>>>array([[  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [ 10.,  20.,  30.,  40.,  50.],
       [ 60.,  70.,  80.,  90., 100.],
       [110., 120., 130., 140., 150.],
       [  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [  0.,   0.,   0.,   1.,   1.],
       [ 10.,  20.,  30.,  40.,  50.],
       [ 60.,  70.,  80.,  90., 100.],
       [110., 120., 130., 140., 150.]])
```



## 2차원 그리드 포인트 생성

- `meshgrid` 명령은 사각형 영역을 구성하는 가로축의 점들과 세로축의 점을 나타내는 두 벡터를 인수로 받아서 이 사각형 영역을 이루는 조합을 출력한다. 결과는 그리드 포인트의 x 값만을 표시하는 행렬과 y 값만을 표시하는 행렬 두 개로 분리하여 출력한다.

```python
x = np.arange(3)
x
>>>array([0, 1, 2])

y = np.arange(5)
y
>>>array([0, 1, 2, 3, 4])

X, Y = np.meshgrid(x, y)

X
>>>array([[0, 1, 2],
       [0, 1, 2],
       [0, 1, 2],
       [0, 1, 2],
       [0, 1, 2]])

Y
>>>array([[0, 0, 0],
       [1, 1, 1],
       [2, 2, 2],
       [3, 3, 3],
       [4, 4, 4]])

[list(zip(x, y)) for x, y in zip(X, Y)]
>>>[[(0, 0), (1, 0), (2, 0)],
 [(0, 1), (1, 1), (2, 1)],
 [(0, 2), (1, 2), (2, 2)],
 [(0, 3), (1, 3), (2, 3)],
 [(0, 4), (1, 4), (2, 4)]]
```



## 배열의 연산

## 백터화 연산

- 벡터화 연산을 쓰면 명시적으로 반복문을 사용하지 않고도 배열의 모든 원소에 대해 반복연산을 할 수 있다. 

```python
# 벡터화 연산을 쓰지 않을 경우 파이썬의 계산
x = np.arange(1, 10001)
y = np.arange(10001, 20001)

z = np.zeros_like(x)
for i in range(10000):
    z[i] = x[i] + y[i]

z[:10]
>>>array([10002, 10004, 10006, 10008, 10010, 10012, 10014, 10016, 10018,
       10020])
```

```python
# 벡터화 연산을 사용하는 넘파이의 연산
z = x + y
z[:10]
>>>array([10002, 10004, 10006, 10008, 10010, 10012, 10014, 10016, 10018,
       10020])
```

```python
# 사칙연산 뿐만 아닌, 비교 연산과 같은 논리 연산도 가능
a = np.array([1, 2, 3, 4])
b = np.array([4, 2, 2, 4])
a == b
>>>array([False,  True, False,  True])	# 각각 비교

a >= b
>>>array([False,  True,  True,  True])	# 위치가 다르면 각각 비교해서 T or F 반환

a = np.array([1, 2, 3, 4])
b = np.array([4, 2, 2, 4])
c = np.array([1, 2, 3, 4])

np.all(a == b), np.all(a == c)		# 각각비교가 아닌, 전체 비교시 np.all( ) 사용
>>>False, True
```



## 브로드캐스팅

- 행렬끼리 덧셈혹은 뺼셈을 하려면 두 행렬의 크기가 같아야 함
- 넘파이에서는 서로 다른 크기를 가진 두 배열의 사칙 연산 지원 함 = 브로드캐스팅
- 크기가 작은 배열을 자동으로 반복 확장하여 크기가큰 배열에 맞춤

```python
x = np.vstack([range(7)[i:i + 3] for i in range(5)])
x
>>>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4],
       [3, 4, 5],
       [4, 5, 6]])

y = np.arange(5)[:, np.newaxis]
y
>>>array([[0],
       [1],
       [2],
       [3],
       [4]])

x + y
>>>array([[ 0,  1,  2],
       [ 2,  3,  4],
       [ 4,  5,  6],
       [ 6,  7,  8],
       [ 8,  9, 10]])
```

```python
x = np.vstack([range(7)[i:i + 3] for i in range(5)])
x
>>>array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4],
       [3, 4, 5],
       [4, 5, 6]])

y = np.arange(3)
y
>>>array([0, 1, 2])

x + y
>>>array([[0, 2, 4],
       [1, 3, 5],
       [2, 4, 6],
       [3, 5, 7],
       [4, 6, 8]])
```



## 차원 축소 연산

- 최대/최소: `min`, `max`, `argmin`, `argmax`
- 통계: `sum`, `mean`, `median`, `std`, `var`
- 불리언: `all`, `any`

```python
x = np.array([1, 2, 3, 4])
x
>>>array([1, 2, 3, 4])

np.sum(x), x.sum()
>>>10, 10


x = np.array([1, 3, 2])
x.min(), x.max()
>>>1 , 3

x.argmin(), x.argmax()  # 최솟값의 위치, 최댓값의 위치
>>>0, 1

x = np.array([1, 2, 3, 1])
x.mean() # 평균 값
>>>1.75

np.median(x) # 중앙 값
>>>1.5

np.all([True, True, False]) # all : 전부 참인가
>>>False

np.any([True, True, False]) # any : 최소 하나이상이 참인가
>>>True

a = np.zeros((100, 100), dtype=np.int)
a
>>>array([[0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           ...,
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0],
           [0, 0, 0, ..., 0, 0, 0]])

np.any(a != 0) # 최소 하나라도 0이 아닌가
>>>False

np.all(a == a) # a 와 a 의 값이 같은가
>>>True

a = np.array([1, 2, 3, 2])
b = np.array([2, 2, 3, 2])
c = np.array([6, 4, 4, 5])
((a <= b) & (b <= c)).all()
>>>True
```

- axis = 0 : 열 연산 (디폴트 값)
- axis = 1 : 행 연산

```python
x = np.array([[1, 1],
              [2, 2]])
x.sum()
>>>6

x.sum(axis=0)   # 열 합계
>>>array([3, 3])

x.sum(axis=1)   # 행 합계
>>>array([2, 4])
```



## 정렬

- sort 함수나 메서드를 사용해 배열 안의 원소를 정렬하여 새로운 배열을 만듬, 2차원 이상일 경우 행이나 열을 각각 따로따로 정렬함.

```python
a = np.array([[4,  3,  5,  7],
              [1, 12, 11,  9],
              [2, 15,  1, 14]])

np.sort(a)  # 각 행 정렬, axis=-1 또는 axis=1 과 동일
>>>array([[ 3,  4,  5,  7],
           [ 1,  9, 11, 12],
           [ 1,  2, 14, 15]])

np.sort(a, axis=0) # 각 열 정렬
>>>array([[ 1,  3,  1,  7],
           [ 2, 12,  5,  9],
           [ 4, 15, 11, 14]])

a = np.array([42, 38, 12, 25])
j = np.argsort(a)	# 행 인덱스 정렬
j
>>>array([2, 3, 1, 0])	# 각 인덱스별 오름 차순

a[j]	# 인덱스정렬
>>>array([12, 25, 38, 42])

x2 = np.array([[  1,    2,    3,    4],     # 학번
                [ 46,   99,  100,   71],    # 영어성적
                [ 81,   59,   90,  100]])   # 수학성적

a = x2[1].argsort()	# 영어성적순 정렬 인덱스 생성
a
>>>array([0, 3, 1, 2], dtype=int64)

x2[:, a]		# 영어 성적순으로 각각의 행을 정렬함
>>>array([[  1,   4,   2,   3],
       [ 46,  71,  99, 100],
       [ 81, 100,  59,  90]])
```



## 기술통계

- 데이터 집합에 대해 간단한 통계를 계산하는 함수
  - 데이터의 개수(count)
  - 평균(mean, average)
  - 분산(variance)
  - 표준 편차(standard deviation)
  - 최댓값(maximum)
  - 최솟값(minimum)
  - 중앙값(median)
  - 사분위수(quartile)

### 데이터의 개수

```python
x = np.array([1, 2, 3, 4, 5])

len(x)  # 갯수
>>>5

x = np.array([18,   5,  10,  23,  19,  -8,  10,   0,   0,   5,   2,  15,   8,
              2,   5,   4,  15,  -1,   4,  -7, -24,   7,   9,  -6,  23, -13])
```



### 표본평균

```python
x = np.array([18,   5,  10,  23,  19,  -8,  10,   0,   0,   5,   2,  15,   8,
              2,   5,   4,  15,  -1,   4,  -7, -24,   7,   9,  -6,  23, -13])

np.mean(x)  # 평균
>>>4.8076923076923075
```



### 표본분산

```python
np.var(x)  # 분산
>>>115.23224852071006
```



### 표본 표준편차

```python
np.std(x)  # 표준 편차
>>>10.734628476137871
```



### 중앙값

```python
np.median(x)  # 중앙값
>>>5.0
```



### 사분위수

-  데이터를 가장 작은 수부터 가장 큰 수까지 크기가 커지는 순서대로 정렬하였을 때 1/4, 2/4, 3/4 위치에 있는 수를 말한다. 각각 1사분위수, 2사분위수, 3사분위수라고 한다. 1/4의 위치란 전체 데이터의 수가 만약 100개이면 25번째 순서, 즉 하위 25%를 말한다. 따라서 2사분위수는 중앙값과 같다.

  때로는 위치를 1/100 단위로 나눈 백분위수(percentile)을 사용하기도 한다. 1사분위수는 25% 백분위수와 같다.

```python
np.percentile(x, 0)  # 최소값
>>>-24.0
np.percentile(x, 25)  # 1사분위 수
>>>0.0
np.percentile(x, 50)  # 2사분위 수
>>>5.0
np.percentile(x, 75)  # 3사분위 수
>>>10.0
np.percentile(x, 100)  # 최댓값
>>>23.0
```



## 난수 발생과 카운팅

- 파이썬을 이용해 데이터를 무작위로 섞거나 난수(임의의 수)를 발생시키는 방법

### 시드 설정하기

- 컴퓨터에서 발생하는 무작위 수는 엄격한 의미의 무작위 수치가 아닌, 특정한 시작 숫자를 정해주면 컴퓨터가 정해진 알고리즘에 의해 난수처럼 보이는 수열을 생성함, 이런 시작 숫자를 seed 라함.

```python
# 1번째 루틴
np.random.seed(0)
np.random.rand(5)
>>>array([0.5488135 , 0.71518937, 0.60276338, 0.54488318, 0.4236548 ])
np.random.rand(10)
array([0.64589411, 0.43758721, 0.891773  , 0.96366276, 0.38344152,
       0.79172504, 0.52889492, 0.56804456, 0.92559664, 0.07103606])
np.random.rand(10)
array([0.0871293 , 0.0202184 , 0.83261985, 0.77815675, 0.87001215,
       0.97861834, 0.79915856, 0.46147936, 0.78052918, 0.11827443])

# 2번째 루틴 ( 1번째와 같은 결과가 나옴 )
np.random.seed(0)
np.random.rand(5)
array([0.5488135 , 0.71518937, 0.60276338, 0.54488318, 0.4236548 ])
np.random.rand(10)
array([0.64589411, 0.43758721, 0.891773  , 0.96366276, 0.38344152,
       0.79172504, 0.52889492, 0.56804456, 0.92559664, 0.07103606])
np.random.rand(10)
array([0.0871293 , 0.0202184 , 0.83261985, 0.77815675, 0.87001215,
       0.97861834, 0.79915856, 0.46147936, 0.78052918, 0.11827443])
```



## 데이터의 순서 바꾸기

- `shuffle` : 함수는 자체 변환(in-place) 함수로 한 번 사용하면 변수의 값이 바뀌므로 사용에 주의해야 한다.

```python
x = np.arange(10)
x
>>>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

np.random.shuffle(x)
x
>>>array([3, 6, 4, 5, 2, 9, 7, 8, 1, 0])
```



## 데이터 샘플링

- 표본선택, 샘플링 : 이미 있는 데이터 집합에서 일부를 무작위로 선택하는 것
- choice

```python
numpy.random.choice(a, size=None, replace=True, p=None)
```

- a : 배열이면 원래의 데이터, 정수이면 arange(a) 명령으로 데이터 생성
- size : 정수. 샘플 숫자
- replace : 불리언. True이면 한번 선택한 데이터를 다시 선택 가능
- p : 배열. 각 데이터가 선택될 수 있는 확률

```python
np.random.choice(5, 5, replace=False)  # shuffle 명령과 같다.
>>>array([1, 4, 0, 3, 2])
np.random.choice(5, 3, replace=False)  # 3개만 선택
>>>array([2, 1, 3])
np.random.choice(5, 10)  # 반복해서 10개 선택
>>>array([0, 4, 1, 4, 1, 2, 2, 0, 1, 1])
np.random.choice(5, 10, p=[0.1, 0, 0.3, 0.6, 0])  # 선택 확률을 다르게 해서 10개 선택
>>>array([0, 3, 3, 2, 2, 3, 3, 2, 0, 3])
```



## 난수 생성

- rand : 0~1 사이의 균일 분포도
- randn : 표준 정규 분포
- randint : 균일 분포의 정수 난수

```python
np.random.rand(10)
array([0.95894927, 0.65279032, 0.63505887, 0.99529957, 0.58185033,
       0.41436859, 0.4746975 , 0.6235101 , 0.33800761, 0.67475232])

np.random.rand(3, 5)	# 행, 열 값을 넣을 시 행열로 만들어짐
array([[0.31720174, 0.77834548, 0.94957105, 0.66252687, 0.01357164],
       [0.6228461 , 0.67365963, 0.971945  , 0.87819347, 0.50962438],
       [0.05571469, 0.45115921, 0.01998767, 0.44171092, 0.97958673]])
```

```python
np.random.randn(10)
array([-0.30237513, -2.2244036 ,  0.72400636,  0.35900276,  1.07612104,
        0.19214083,  0.85292596,  0.01835718,  0.42830357,  0.99627783])

np.random.randn(3, 5)
array([[-0.49114966,  0.71267817,  1.11334035, -2.15367459, -0.41611148],
       [-1.07089699,  0.22113881, -1.12305712, -1.05075796,  1.01207905],
       [ 1.54371643, -0.40211489,  0.8647491 , -0.22686923,  0.81116027]])
```

- `randint` 함수는 다음과 같은 인수를 가진다.

  ```
  numpy.random.randint(low, high=None, size=None)
  ```

  만약 `high`를 입력하지 않으면 0과 `low`사이의 숫자를, `high`를 입력하면 `low`와 `high`는 사이의 숫자를 출력한다. `size`는 난수의 숫자이다.

```python
np.random.randint(10, size=10)
array([0, 4, 3, 6, 9, 8, 0, 8, 5, 9])

np.random.randint(10, 20, size=10)
array([10, 19, 16, 15, 13, 11, 18, 10, 14, 19])

np.random.randint(10, 20, size=(3, 5))
array([[16, 15, 17, 18, 18],
       [19, 12, 18, 16, 16],
       [19, 11, 16, 18, 18]])
```



## 정수 데이터 카운팅

- unique : 데이터에서 중복된 값을 제거하고 중복되지 않은 값의 리스트를 출력
- return_counts= : True 로 설정시 각 값을 가진 데이터 갯수를 출력함, 단 특정 점위중 한번도 숫자가 나오지 않을 경우 그 숫자는 0으로도 표기하지 않음

```python
np.unique([11, 11, 2, 2, 34, 34])
>>>array([ 2, 11, 34])

a = np.array(['a', 'b', 'b', 'c', 'a'])
index, count = np.unique(a, return_counts=True)
index
>>>array(['a', 'b', 'c'], dtype='<U1')

count
>>>array([2, 2, 1])
```

- bincount, minlength=숫자 : 0부터 minlength -1 까지 숫자에 대해 각각 카운트를 함, 데이터가 없을 경우 0이 됨

```python
np.bincount([1, 1, 2, 2, 2, 3], minlength=6)
>>>array([0, 2, 3, 1, 0, 0])
		#0  1  2  3  4  5   각각 카운트함
```



