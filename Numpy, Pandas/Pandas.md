# Pandas

## 판다스 데이터 분석

- Numpy : 행row 열col 위주
- Pandas
  - Series가 묶여있는 2차원 표 = DataFrame 위주
    - series 열 하나 하나의미 numpy 값으로 가지고 있으나 index를 가지고 있음
  - 시리즈와 데이터프레임을 만들 수 있다.
  - 판다스를 이용하여 csv 파일을 읽고 쓸 수 있다.
    - 엑셀보다 더많은 데이터를 작업 할 수 있음.
  - 시리즈와 데이터프레임에서 원하는 데이터를 읽고 갱신하는 방법을 익힌다.
  - 시리즈와 데이터프레임의 데이터를 조작하는 법을 공부한다.
  - 멀티 인덱스와 이를 다루는 방법을 학습한다.
  - 둘 이상의 데이터프레임을 하나로 합치는 법을 익힌다.
  - 데이터를 그룹으로 나누어 분석하고 피봇테이블을 만드는 방법을 공부한다.

## Series

- 시리즈의 값은 시리즈 단독 사용보다 데이터 프레임으로 많이 사용 됨
- 시작하기 전 아래 2개 필수

```python
import numpy as np
import pandas as pd
```

- 시리즈 = 값(value) + 인덱스(index)
  - 시리즈는 데이터의 type은 넘파이와 같음
- 시리즈 생성방법

```python
s = pd.Series(값)
```

- 값을 주는 방법은 여러가지 임

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052])
s
>>> 0    9904312
    1  	  3448737
    2    2890451
    3    2466052
    dtype: int64
```

- 넘파이 기반의 타입, 
- index를 지정하지 않으면 0 1 2 3 인덱스가 생김

```python
s = pd.Series([9904312, 3448737, 2890451, 2466052],
              index=["서울", "부산", "인천", "대구"], dtype=np.int32)
s

>>> 서울    9904312
    부산    3448737
    인천    2890451
    대구    2466052
    dtype: int32
```

- 시리즈에 인덱스 값 부여, 타입 지정 가능

```python
# 시리즈의 값 - 넘파이 배열
s.values
>>>array([9904312, 3448737, 2890451, 2466052])

# 시리즈의 인덱스
s.index
>>>Index(['서울', '부산', '인천', '대구'], dtype='object')
```

```python
# 시리즈의 이름 설정 가능
s.name = '인구'
s.index.name = '도시'
s

>>> 도시
    서울    9904312
    부산    3448737
    인천    2890451
    대구    2466052
    Name: 인구, dtype: int32
```

### 시리즈의 연산

```python
s / 1000000

>>> 도시
    서울    9.904312
    부산    3.448737
    인천    2.890451
    대구    2.466052
    Name: 인구, dtype: float64
```

- 값 만 변경 됨, 시리즈의 데이터는 넘파이 기반이기 때문

### 시리즈 인덱싱

```python
s[1], s['부산']
>>> (3448737, 3448737)
```

- 인덱스값 호출 방법

```python
s[[0,3,1]], s[["서울", "대구", "부산"]]

>>> (도시
     서울    9904312
     대구    2466052
     부산    3448737
     Name: 인구, dtype: int32,
     도시
     서울    9904312
     대구    2466052
     부산    3448737
     Name: 인구, dtype: int32)
```

- 인덱스는 키와 같음
- 리스트 형태로 호출시 시리즈 형식으로 볼 수 있음
- 넘파이의 fancy indexing 과 같음

```python
# slicing
s[1:3]
>>> 도시
    부산    3448737
    인천    2890451
    Name: 인구, dtype: int32
s['부산':'대구']
>>> 도시
    부산    3448737
    인천    2890451
    대구    2466052
    Name: 인구, dtype: int32
```

- 슬라이싱시 인덱스 번호가 아닌 인덱스 명으로 호출시 호출한 인덱스까지 출력 됨

```python
# 필터링
# & - and
s[(2500000 < s) & (s<3000000)]
# s[2500000 < s < 3000000] 은 사용 불가
>>> 도시
    인천    2890451
    Name: 인구, dtype: int32
        
# | - or 
s[(s < 2500000) | (s > 4e6)]       
# e숫자 0의 갯수만큼 추가   
>>> 도시
    서울    9904312
    대구    2466052
    Name: 인구, dtype: int32
```

```python
# 한글 인덱스도 호출 가능
s.부산
>>> 3448737
```

### 시리즈와 딕셔너리

```python
s2 = pd.Series({"서울": 9631482, "부산": 3393191, "인천": 2632035, "대전": 1490158})
s2
>>> 서울    9631482
    부산    3393191
    인천    2632035
    대전    1490158
    dtype: int64
    
'서울' in s, '대구' in s2
>>> (True, False)
```

- 딕셔너리와 같은 기능 가능
- 인덱스 명만으로도 in 과 같은 검사 가능
- 단, 딕셔너리를 활용한 시리즈 생성은 권장하지 않음 가능하다는 것만 인지, 딕셔너리는 정렬이 어려움

```python
s2 = pd.Series({"서울": 9631482, "부산": 3393191, "인천": 2632035, "대전": 1490158},
               index=["부산", "서울", "인천", "대전"])
s2
>>> 부산    3393191
    서울    9631482
    인천    2632035
    대전    1490158
    dtype: int64
```

- 위와 같이 인덱스를 따로 지정해 주어야 정렬 가능

### 인덱스 기반 연산

```python
s

>>> 서울    9904312
    부산    3448737
    인천    2890451
    대구    2466052

s2
>>> 부산    3393191
    서울    9631482
    인천    2632035
    대전    1490158
    dtype: int64
    
s - s2
>>> 대구         NaN
    대전         NaN
    부산     55546.0
    서울    272830.0
    인천    258416.0
    dtype: float64
```

- 키값이 같은 값이 있으면 빼주지만 다르면 안빼줌

```python
s.values - s2.values
>>> array([272830,  55546, 258416, 975894], dtype=int64)
```

- values를 사용시 값끼리 빼주므로 넘파이 식으로 계산됨

```python
rs = (s - s2) / s2 * 100
rs
>>> 대구         NaN
    대전         NaN
    부산    1.636984
    서울    2.832690
    인천    9.818107
    dtype: float64

rs.notnull()
>>> 대구    False
    대전    False
    부산     True
    서울     True
    인천     True
    dtype: bool

rs[rs.notnull()]
>>> 부산    1.636984
    서울    2.832690
    인천    9.818107
    dtype: float64
```

### 데이터의 갱신, 추가, 삭제

```python
# 데이터 갱신
rs['부산'] = 1.63
rs
>>> 부산    1.630000
    서울    2.832690
    인천    9.818107
    dtype: float64
    
# 데이터 추가    
rs['대구'] = 1.41
rs
>>> 부산    1.630000
    서울    2.832690
    인천    9.818107
    대구    1.410000
    dtype: float64
    
# 데이터 삭제
del rs['부산']
rs
>>> 서울    2.832690
    인천    9.818107
    대구    1.410000
    dtype: float64
```

## DataFrame

- DataFram 은 클래스임, Series 도 클래스 대문자로 시작함!

```python
import numpy as np
import pandas as pd
```

### 데이터프레임 생성

- 데이터 프레임은 2차원 모양을 가지고 있음
- 데이터프레임을 만드는 방법은 다양하다. 가장 간단한 방법은 다음과 같다.
  1. 우선 하나의 열이 되는 데이터를 리스트나 일차원 배열을 준비한다.
  2. 이 각각의 열에 대한 이름(라벨)을 키로 가지는 딕셔너리를 만든다.
  3. 이 데이터를 `DataFrame` 클래스 생성자에 넣는다. 동시에 열방향 인덱스는 `columns` 인수로, 행방향 인덱스는 `index` 인수로 지정한다.

```python
data = {
    "2015": [9904312, 3448737, 2890451, 2466052],
    "2010": [9631482, 3393191, 2632035, 2431774],
    "2005": [9762546, 3512547, 2517680, 2456016],
    "2000": [9853972, 3655437, 2466338, 2473990],
    "지역": ["수도권", "경상권", "수도권", "경상권"],
    "2010-2015 증가율": [0.0283, 0.0163, 0.0982, 0.0141]
}
columns = ["지역", "2015", "2010", "2005", "2000", "2010-2015 증가율"]
index = ["서울", "부산", "인천", "대구"]
df = pd.DataFrame(data, index=index, columns=columns)
df

>>> 	  지역	2015	2010	2005	2000	2010-2015 증가율
    서울	수도권	9904312	9631482	9762546	9853972		0.0283
    부산	경상권	3448737	3393191	3512547	3655437		0.0163
    인천	수도권	2890451	2632035	2517680	2466338		0.0982
    대구	경상권	2466052	2431774	2456016	2473990		0.0141
```

- 행인덱스 = index
- 열인덱스 = columns

```python
# 전치 행과 열을 뒤집음
df.T
>>>         도시	   서울	부산	 인천	  대구
            특성				
            지역	   수도권	경상권	수도권	경상권
            2015	9904312	3448737	2890451	2466052
            2010	9631482	3393191	2632035	2431774
            2005	9762546	3512547	2517680	2456016
            2000	9853972	3655437	2466338	2473990
2010-2015 증가율	 0.0283	0.0163	0.0982	0.0141
```

### 열 데이터의 갱신, 추가, 삭제

```python
# 갱신 - 백분율로 변환
df['2010-2015 증가율'] = df['2010-2015 증가율'] * 100
df
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율
    도시						
    서울	수도권	9904312	9631482	9762546	9853972	2.83
    부산	경상권	3448737	3393191	3512547	3655437	1.63
    인천	수도권	2890451	2632035	2517680	2466338	9.82
    대구	경상권	2466052	2431774	2456016	2473990	1.41

# 추가 - 열에 리스트 값을 주면 추가가됨
df['2020'] = [1, 2, 3, 4]
df
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율	2020
    도시							
    서울	수도권	9904312	9631482	9762546	9853972	2.83				1
    부산	경상권	3448737	3393191	3512547	3655437	1.63				2
    인천	수도권	2890451	2632035	2517680	2466338	9.82				3
    대구	경상권	2466052	2431774	2456016	2473990	1.41				4

# 삭제 - del['삭제할열'] 열의 인덱스 삭제
del df['2020']
df
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율
    도시						
    서울	수도권	9904312	9631482	9762546	9853972	2.83
    부산	경상권	3448737	3393191	3512547	3655437	1.63
    인천	수도권	2890451	2632035	2517680	2466338	9.82
    대구	경상권	2466052	2431774	2456016	2473990	1.41
```

### 열 인덱싱

```python
type(df['지역']), type(df[['지역']])
(pandas.core.series.Series, pandas.core.frame.DataFrame)
# 하나의 열만 인덱싱하면 시리즈가 반환된다.
df["지역"]
>>> 도시
    서울    수도권
    부산    경상권
    인천    수도권
    대구    경상권
    Name: 지역, dtype: object
            
# 여러개의 열을 인덱싱하면 부분적인 데이터프레임이 반환된다.
df[["2010", "2015"]]
>>> 특성	2010	2015
    도시		
    서울	9631482	9904312
    부산	3393191	3448737
    인천	2632035	2890451
    대구	2431774	2466052
    
# 2010이라는 열을 반환하면서 데이터프레임 자료형을 유지
df[["2010"]]
>>> 특성	2010
    도시	
    서울	9631482
    부산	3393191
    인천	2632035
    대구	2431774
   
# 2010이라는 열을 반환하면서 시리즈 자료형으로 변환
df["2010"]
>>> 도시
    서울    9631482
    부산    3393191
    인천    2632035
    대구    2431774
    Name: 2010, dtype: int64
```

- 리스트로 한번더 감싸는 것에 차이, 시리즈와 데이터 프레임

### 행 인덱싱

```python
# 슬라이싱으로 해야만 행이 보임 슬라이싱 없이는 오류
df[:'서울']
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율
    도시						
    서울	수도권	9904312	9631482	9762546	9853972	2.83

df[1:2]
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율
    도시						
    부산	경상권	3448737	3393191	3512547	3655437	1.63

df['부산':'인천']
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율
    도시						
    부산	경상권	3448737	3393191	3512547	3655437	1.63
    인천	수도권	2890451	2632035	2517680	2466338	9.82
```

- 행단위로 인덱싱을 하려면 반드시 슬라이싱을 해야 함
- 숫자로 하는것과, 키로 부르는 것의 차이 유의

```python
df.head(3)
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율
    도시						
    서울	수도권	9904312	9631482	9762546	9853972	2.83
    부산	경상권	3448737	3393191	3512547	3655437	1.63
    인천	수도권	2890451	2632035	2517680	2466338	9.82

df.tail(3)
>>> 특성	지역	2015	2010	2005	2000	2010-2015 증가율
    도시						
    부산	경상권	3448737	3393191	3512547	3655437	1.63
    인천	수도권	2890451	2632035	2517680	2466338	9.82
    대구	경상권	2466052	2431774	2456016	2473990	1.41
```

- 행인덱싱 보다는 head 와 tail을 많이 사용 값을 부여하지 않을 경우 5개 자동출력됨
- 많은 행이 있을 경우 그냥 df 를 호출하면 위로 5개 아래로 5개 출력됨

### 개별 데이터 인덱싱

- df[\'열이름']\['행이름'] 으로 호출함

```python
df['2015']['서울'], df['2015'][0]
9904312
```

### 데이터 입출력

- 판다스가 지원하는 데이터 파일 포멧
  - CSV
  - Excel
  - HTML
  - JSON
  - HDF5
  - SAS
  - STATA
  - **SQL**

### CSV 파일 입력

- ```
  pd.read_csv('sample1.csv')
  ```

  |      |   c1 |   c2 |    c3 |
  | ---: | ---: | ---: | ----: |
  |    0 |    1 | 1.11 |   one |
  |    1 |    2 | 2.22 |   two |
  |    2 |    3 | 3.33 | three |

- 행인덱스 정보가 없어 행인덱스가 자동으로 0부터 시작되어 추가됨

```python
pd.read_csv('sample2.csv', names=['c1', 'c2', 'c3']) # 인덱스가 없을 경우 인덱스를 지정하며 읽을수 있음

pd.read_csv('sample1.csv', index_col='c1')
# 인덱스로 지정 하고싶은 열이 있을 경우 index_col을 통해 인덱스로 지정할 수 있음

# CSV가 아닌 파일중, 데이터를 구분하는 구분자가 ,가아닌 길이가 정해지지 않은 공백이 구분자일 경우
pd.read_table('sample3.txt', sep='\s+')
# sep='\s+' 를 통해 읽어올 수 있음

# 자료파일 내용중 건너뛰어야 할 행이 있다면 skprows=[시작행,끝행] 를 통해 읽을 수 있음 
pd.read_csv('sample4.txt', skiprows=[0, 1])

# 특정 값을 NaN 값으로 취급해야 할 경우 na_valeus=['변경할값']
pd.read_csv('sample5.csv', na_values=['누락'])


```





### CSV 파일 출력

- 파이썬 데이터프레임 값을 csv파일로 출력할 경우

```python
df.to_csv('sample6.csv')

# 출력시 sep 인수로 구분자의 모양을 바꿔줄 수 있음
df.to_csv('sample7.txt', sep='|')

# nan 값을 na_rep='변경값' 을 통해 변경하여 출력할 수 있음
df.to_csv('sample8.csv', na_rep='누락')

# index= , header= 을 통해 값을 출력하지 않을 수 있음
df.to_csv('sample9.csv', index=False, header=False)
```



## 데이터프레임 고급 인덱싱

- loc : 라벨값 기반의 2차원 인덱싱
- iloc : 순서를 나타내는 정수 기반의 2차원 인덱싱

### loc 인덱서

- df.loc[행인덱싱값, 열인덱싱값]

```python
df = pd.DataFrame(np.arange(10, 22).reshape(3, 4),
                  index=["a", "b", "c"],
                  columns=["A", "B", "C", "D"])

df.loc["a"] # 행하나 선택시 시리즈로 나옴
>>> A    10
    B    11
    C    12
    D    13
    Name: a, dtype: int64
            
df.loc["b":"c"] # =df["b":"c"] : 행을 하나이상 선택시 DataFrame 형태로 출력됨
>>> A	B	C	D
    b	14	15	16	17
    c	18	19	20	21
    
df.A > 15 # 열 데이터 조건문 비교 가능
>>> a    False
    b    False
    c     True
    Name: A, dtype: bool
            
df.loc[df.A > 15] # 열에 조건을 걸고 loc 로 묶으면 해당하는 값을 데이터 프레임으로 출력
>>> A	B	C	D
    c	18	19	20	21
```



```python
df2 = pd.DataFrame(np.arange(10, 26).reshape(4, 4), columns=["A", "B", "C", "D"])
df2
>>>     A	B	C	D
    0	10	11	12	13
    1	14	15	16	17
    2	18	19	20	21
    3	22	23	24	25
    

df.loc["a", "A"] # 행, 열 값 받을 경우
>>> 10

df.loc["b":, "A"] # 슬라이싱 사용시 시리즈로 반환
>>> b    14
    c    18
    Name: A, dtype: int64
            
df.loc["a", :]
>>> A    10
    B    11
    C    12
    D    13
    Name: a, dtype: int64
            
df.loc[["a", "b"], ["B", "D"]] # 행, 열값을 두개이상 줄경우 데이터프레임으로 반환
>>> B	D
    a	11	13
    b	15	17

df.loc[df.A > 10, ["C", "D"]] # 2개이상의 값을 반환하는 불일 경우에도 데이터 프레임 반환 가능
>>> C	D
    b	16	17
    c	20	21
```



### iloc 인덱서

```python
df.iloc[0, 1]
>>> 11

df.iloc[:2, 2] 
>>> a    12
    b    16
    Name: C, dtype: int64

df.iloc[0, -2:]
>>> C    12
    D    13
    Name: a, dtype: int64
        
df.iloc[2:3, 1:3]
>>> B	C
    c	19	20

df.iloc[-1]
>>> A    18
    B    19
    C    20
    D    21
    Name: c, dtype: int64
        
df.iloc[-1] = df.iloc[-1] * 2 # 마지막 행에 *2 값 적용
df
>>> 	A	B	C	D
    a	10	11	12	13
    b	14	15	16	17
    c	36	38	40	42
```



## 데이터프레임의 데이터 조작

### 데이터 갯수 세기

- count()

```python
s = pd.Series(range(10))
s[3] = np.nan
s
>>> 0    0.0
    1    1.0
    2    2.0
    3    NaN
    4    4.0
    5    5.0
    6    6.0
    7    7.0
    8    8.0
    9    9.0
    dtype: float64

s.count() 	# nan 값을 제외한 값을 카운트함
>>> 9

np.random.seed(2)
df = pd.DataFrame(np.random.randint(5, size=(4, 4)), dtype=float)
df.iloc[2, 3] = np.nan
df
>>> 	0	1	2	3
    0	0.0	0.0	3.0	2.0
    1	3.0	0.0	2.0	1.0
    2	3.0	2.0	4.0	NaN
    3	4.0	3.0	4.0	2.0

df.count() # 데이터 프레임의 경우 각 열의 값을 카운트 함
>>> 0    4
    1    4
    2    4
    3    3
    dtype: int64
```



### 카테고리 값 세기

```python
np.random.seed(1)
s2 = pd.Series(np.random.randint(6, size=100))
s2.value_counts() # 시리즈에서는 value_counts() 를 통해 각 값에 대한 횟수를 카운트 가능
>>> 1    22
    0    18
    4    17
    5    16
    3    14
    2    13
    dtype: int64
        
# 단, 데이터 프레임에는 value_counts() 메서드가 없음
df[0].value_counts()
>>> 3.0    2
    4.0    1
    0.0    1
    Name: 0, dtype: int64
# 각 열마다 별도로 확인 해야 함
```



### 정렬

- sort_index : 인덱스 값 기준으로 정렬
- sort_values : 데이터 값 기준으로 정렬

```python
s2.value_counts().sort_index()
0    18
1    22
2    13
3    14
4    17
5    16
dtype: int64
    
s.sort_values()
0    0.0
1    1.0
2    2.0
4    4.0
5    5.0
6    6.0
7    7.0
8    8.0
9    9.0
3    NaN
dtype: float64
    
s.sort_values(ascending=False) # ascending=False 사용시 내림차순
9    9.0
8    8.0
7    7.0
6    6.0
5    5.0
4    4.0
2    2.0
1    1.0
0    0.0
3    NaN
dtype: float64  
    

df.sort_values(by=1)
0	1	2	3
0	0.0	0.0	3.0	2.0
1	3.0	0.0	2.0	1.0
2	3.0	2.0	4.0	NaN
3	4.0	3.0	4.0	2.0
```

